# JVM-Java内存模型



## Java 运行时数据区

### 堆

线程共享的。

堆是 Java 最大的一块内存，是 GC 回收的主要区域（另一块区域是方法区）。

几乎所有的对象都在这里被分配内存(JDK1.7开始默认启用了逃逸分析，如果只是在方法中被创建而没有被外界所引用，则直接在栈中分配内存)。

堆被划分为了 **年轻代、老年代**；**年轻代**又被分为了 **Eden区、Survivor0区、Survivor1区**。将堆内存这么细划分，好处在于：可以针对不同分区内存采用不同的内存分配策略和GC回收策略，进行更细粒度的控制，提升内存分配、回收性能。



### 栈

线程私有的。

FILO(先进后出）。栈分为虚拟机栈、本地方法栈。

进入一个新方法时，会在栈上划分一块内存作为该方法的**栈帧**；从一个方法中退出时（不管是正常 return 还是异常退出），该栈帧都会被释放掉。栈不需要 GC 进行回收。

tip: **C/C++ 进行方法调用时，call 指令会将 SP 寄存器保存在栈中；从方法返回时，return 指令会将 SP 指针从栈中弹出并赋值给 SP。这两条指令保证了栈帧的释放。**

```assembly
call method -> push SP
return -> pop SP
```

一个栈帧包含了：局部变量表、操作数栈（临时存储运算结果、变量值的地方）、动态链接（符号引用->方法区中方法的直接引用）、方法出口（方法调用的下一条指令的地址）。

虚拟机栈是为 Java 方法服务的，本地方法栈就是为 native 方法服务的。



### 方法区

线程共享的。

GC 回收的一块区域（回收频率低，只有在 **Full GC** 时回收）。

方法区是 Java 虚拟机规范中规定的一个区域，不是最终的实现，只是制定的一个规范。

它存储每个类的结构，例如**运行时常量池**、字段和方法数据，以及方法和构造函数的代码，包括类和接口初始化以及实例初始化中使用的特殊方法。

JDK 1.7 之前，HotSpot 方法区的实现是永久代运行时常量池包含了：类元信息、运行时常量池、JIT 代码缓存。

JDK 1.7 时，字符串常量、静态变量从永久代移动到了堆中。

JDK 1.8 时，永久代被废弃，转而使用元空间实现，元空间使用的本地内存实现的。

Java 内存中有相当大一块空间是用于存储字符串的，而很多字符串（toString() 产生的）都是只用一次，每次的字符串大概率不相同；如果字符串常量放在方法区中，很难及时回收。因此，放到堆中后，内存回收性能会更好。

#### 运行时常量池

Java 虚拟机为每个类和接口维护一个运行时常量池，这种数据结构和传统编程语言实现的符号表的目的基本一致。

运行时常量池中有两种条目：**符号引用**（稍后可能会被解析)，以及不需要进一步处理的**静态常量**。

##### 符号引用

运行时常量池中的**符号引用**是根据constant_pool表中每个条目的结构派生出来的。

##### 静态常量

运行时常量池中的**静态常量**也根据每个条目的结构从constant_pool表中的条目派生出来。

包含了字符串常量、数字常量。



### PC-程序计数器

线程私有的。

用于保存线程当前正在执行的 Java 虚拟机指令的地址。注意，只能保存执行 Java 虚拟机指令的地址，不能保存 native 指令的地址。

JVM 是用内存模拟了一个 PC。



## 直接内存

直接内存不属于 JVM 的运行时数据区域，Java 的 NIO 使用到的内存是直接使用 native 方法分配的直接内存，避免了在 JVM 内存和 native 内存之间复制。



## 对象创建过程

一个简单的 new XXX 代码创建 Java 对象分为以下几个步骤。

### 类加载检查

创建一个类的实例，得先确定这个类是什么，所以，先要进行类的加载检查。

如果该类没有被加载过，则需要进行加载、解析、初始化。

### 分配内存

确定了这个类是什么，我们就能确定这个对象会有多大。

接下来，就需要为该对象找到合适的存储空间。

分配内存有两种方式：指针碰撞、空闲列表。

**指针碰撞：**

适合内存规整的情况下使用。

使用一个指针，指针的一方是已分配内存，另一方是未分配内存。只需要将该指针往未分配内存的方向移动对象大小的地址即可。

**空闲列表**：

适合内存不规整的情况下使用。

操作系统为程序分配内存也有使用到空闲列表。

列表的结点存储空闲内存的起始地址。分配策略有：最差匹配、最优匹配等算法。

### 初始化零值

Java 类的属性有一个特点：不需要赋值即可使用。但是，方法中的变量不先赋值是不可以直接使用的。

引在这个过程中，对引用类型赋 null，原始类型赋 0。（null 本质上来说也是0)

### 设置对象头

对象头分为 Mark Word、指向类元数据的指针、数组长度（数组对象特有）。

在这个过程中，设置其指向类元数据的指针、数组长度（如有必要）、分代年龄、hashcode 值、锁标志等。

### 执行构造方法

完成上述所有步骤后，才会来到构造方法，正式进入到 Java 代码执行中。



## 对象的访问方式

创建对象就是为了去使用它。我们通过引用去访问对象的方式取决于虚拟机。有两种方式：使用句柄、直接指针。

**句柄**

引用指向的是内存中的句柄，句柄包含了分别指向对象的实例数据、类型数据的两个指针。**优点：对象在内存中移动了，但是引用不需要改变，只需要改变句柄即可。**

**直接指针**

引用指向的是对象的地址，对象中包含了指向类型数据的指针。**优点：速度快，一次内存引用即可访问对象。**



