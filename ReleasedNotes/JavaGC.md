## GC算法
1. Mark-Sweep（标记-清除）：第一阶段GCRoots开始标记对象，第二阶段将未标记的对象清除。容易留下内存碎片，存活对象较多时比较有效。
2. Mark-Compact（标记-整理）：第一阶段是一样的，第二阶段是利用回收算法整理内存碎片。比如双指针。
3. Copying（复制）：将内存空间分为两半，而且还要复制对象，因此空间开销大，同时整理时间与存活对象的大小成正比。

三种算法各有利弊，要针对不同场景选择不同的算法。这也就是为什么要分代的原因。

## 主要的垃圾收集器

1. CMS（Concurrent Mark-Sweep）：从名字上就能知道CMS是采用何种算法的了。CMS分为四个阶段：初始标记、并发标记、最终标记、并发清除。
会导致大量的内存碎片。在JDK14中被删除。
2. G1（Garbage first）：G1采用的是复制算法，前四个阶段和上面的相同，第5个阶段是进行复制。G1和CMS都是并发的，但是G1的等待时间是可配置的。
STW时间与存活对象的大小成正比。
3. ZGC：G1的问题就在于：复制阶段不能像标记阶段那样并发进行，而是STW。ZGC解决了在并发复制阶段时，对象地址的重定位问题。采用的读屏障技术。

在GC过程中，还有会新的请求进来，因此还会分配新的对象，那么线程可能会因为内存不足而阻塞。这是由于GC触发不及时，引起了内存阻塞。
GC如果触发及时，但是标记和回收速度过慢的话，还是会导致线程阻塞。因此可以适当提高GC线程分配的核数。
